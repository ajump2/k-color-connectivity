(* ::Package:: *)

(* Mathematica package *)
(* Authors: Alexander Halperin, Adam Jump *)
BeginPackage["kColorConnectivity`"]

GraphColoring::usage=
"GraphColoring[graph] takes a graph as an argument, reverses the vertex set of the graph, 
and colors each edge with a randomly generated color";

GraphReOrdering::usage=
"GraphReOrdering[graph] takes a graph as an argument, 
and reverses the vertex set of the graph";

VerticesWithNoKPath::usage=
"VerticesWithNoKPath[Vertices,dataset] takes the order of a graph and the KColorDataset as arguments,
and returns a graph with chords representing the pairs of vertices with no path of length k";

ProblematicVertices::usage=
"ProblematicVertices[n,k] takes the order of a graph and path length k as arguments,
";

OneChordAddition::usage=
"OneChordAddition[n] takes the order of a graph as its argument,
it then determines the ways we can add one chord to the graph and returns those graphs";

ChordMapPathDNE::usage=
"ChordMapPathDNE[n,k] take the order of a graph and the path length k as arguments,
it finds and returns a dataset of one graph from each isomorphism class,
mapped to a graph that has edges between vertices that do not have a path of length k from the key graph";

KeyValueFunction::usage=
"KeyValueFunction[graph1,graph2] takes two graphs as arguments. 
In the second argument, if more than one vertex of degree exactly two exists,
those vertices are paired to create an edge. 
This edge is then added to the first graph argument, and appended to a list.
Returns the list when complete";

TwoChordAdditionsFunction::usage=
"TwoChordAdditionsFunction[n,k] takes the order of a graph and path of length k as arguments.
returns a dataset with all graphs that may have a path of length k.
***Note*** Still needs to be Modified for non-intersecting chords";

KPathTest::usage=
"KPathTest[graph,{x,y},a] determines whether a path at least a exists,
 from a until infinity and generates an association with the data";
 
KPathAssociation::usage=
"KPathAssociation[graph,k] generates the vertex pairs in a graph,
 and determines whether a path of length k exists between all vertex pairs";

ColorAssociation::usage=
"ColorAssociation[graph,{x,y},a] finds a path with a colors in a graph, 
between the vertices x and y";
 
KColorExist::usage=
"KColorExist[graph,k] uses the ColorAssociation to check all vertex pairs in graph for k colors, and
returns Yes if so, if {Yes,No} or {No,Yes} or {No} is printed, the graph is not k-color connected";

KColorsTest::usage=
"KColorsTest[graph,{x,y},a] returns an association that gives all paths of length a highlighted in graph,
between vertices x and y";

KColorDataset::usage=
"KColorDataset[graph,k] generates a dataset using the KColorsTest with the path length specified as k,
 between all vertex pairs in graph. 
Note: Assign this function to a variable before executing";

PathLookup::usage=
"PathLookup[dataset,vertexpair,kcolors] searches a dataset generated by KColorDataset, 
between a vertex pair ({1,2} is denoted 1, {1,3} as 2, etc...)";

IsomorphismTest::usage=
"IsomorphismTest[graph,a] determines whether a graph in position 1, 
and each graph in a set of graphs in position 2, are isomorphic";

IsomorphismModule::usage=
"IsomorphismModule[graphset] determines which graphs in graphset are 
isomorphic to one another, and returns one graph from every 
isomorphism class";

CompleteBipartiteEdgeAdder::usage=
"CompleteBipartiteEdgeAdder[vertices,list,chords,pathlength] takes the chords from a circulant graph on vertices specified by list, and
adds them to a cycle, it then sorts through which graphs are
isomorphic to one another, and searches each for paths at least pathlength in length";

ChordedCycle::usage=
"ChordedCycle[vertices,chords,pathlength] takes chords from a complete graph on vertices, and determines which have a path at least pathlength in length";

CompleteBipartiteEdgeColorer::usage=
"CompleteBipartiteEdgeColorer[n] Returns a k-color connected complete graph on n vertices";

Begin["`Private`"]
 
GraphColoring[graph_]:=Graph[
Reverse[
Range[
VertexCount[
graph]
]
],
Map[
Style[
#,RandomColor[]
]&,
EdgeList[
graph]
],
GraphLayout->"CircularEmbedding",
VertexLabels->"Name"]
Clear[GraphReOrdering]
GraphReOrdering[graph_]:=Graph[
Reverse[
Range[
VertexCount[
graph]
]
],
EdgeList[graph],
GraphLayout->"CircularEmbedding",
VertexLabels->Placed["Name",Center],
VertexSize->0.3]
Clear[VerticesWithNoKPath]
VerticesWithNoKPath[Vertices_,dataset_]:=
HighlightGraph[
EdgeAdd[
CycleGraph[
Vertices],
Cases[
Values[
dataset[
Select[
Length[
#"Paths with k or more colors"]==0&
]
]
]//Normal,{{x_,y_},{}}->UndirectedEdge[x,y]]],
Cases[
Values[
dataset[
Select[
Length[
#"Paths with k or more colors"]==0&
]
]
]//Normal,
{{x_,y_},{}}->UndirectedEdge[x,y]
]
]

Clear[ProblematicVertices]
ProblematicVertices[n_,k_]:=
Map[
VerticesWithNoKPath[n,#]&,
Map[
KColorDataset[#,k]&,
Map[
GraphColoring[#]&,
Map[
EdgeAdd[CycleGraph[n],#]&,
Flatten[
Subsets[
Complement[
EdgeList[
CompleteGraph[n]
],
EdgeList[CycleGraph[n]
]
],
1]
]
]
]
]
]
Clear[OneChordAddition]
OneChordAddition[n_]:=Map[
EdgeAdd[CycleGraph[n],#]&,
Flatten[
Subsets[
Complement[
EdgeList[
CompleteGraph[n]
],
EdgeList[CycleGraph[n]
]
],
1]
]
]
Clear[ChordMapPathDNE]
ChordMapPathDNE[n_,k_]:=
Dataset[
Inner[
Rule,
Catch[
ReleaseHold[
IsomorphismModule[
OneChordAddition[n]
]
]
],
Catch[
ReleaseHold[
IsomorphismModule[
ProblematicVertices[n,k]
]
]
],Association
]
]
Clear[KeyValueFunction]
KeyValueFunction[graph1_,graph2_]:=
Map[
EdgeAdd[graph1,#]&,
Apply[
UndirectedEdge,
Subsets[
Keys[
Select[
Inner[
Rule,
VertexList[graph2],
VertexDegree[graph2],
Association],
#==2&]
],
{2}],
{1}
]
]
Clear[TwoChordAdditionsFunction]
TwoChordAdditionsFunction[n_,k_]:=
Map[
Select[
#,
SimpleGraphQ
]&,
KeyValueMap[
KeyValueFunction,
ChordMapPathDNE[
n,
k
]
]
]
 
KPathTest[graph_, {x_, y_}, a_] :=
 Association["Path at least k exists" ->
   If[
    Flatten[
      FindPath[graph, x, y, {a, Infinity}]] != {}, "Yes", "No"]

];

KPathAssociation[graph_, k_] :=
DeleteDuplicates[
Flatten[
Values[
 Map[
  KPathTest[graph, ##, k] &,
  Subsets[VertexList[graph], {2}]
  ]
]
]
  ];

ColorAssociation[graph_,{x_,y_},a_]:=
Association[
"Path with k-colors exists"->
If[
Select[
Map[
Length,
Map[
DeleteDuplicates,
Map[
PropertyValue[
{graph,##},EdgeStyle]&,
Map[
EdgeList,Map[PathGraph[##]&,
FindPath[graph,x,y,{a,Infinity},All]
]
]
,{2}]
]
]
,#>=a&,1]!={},"Yes","No"]
];

KColorExist[graph_,k_]:=
DeleteDuplicates[
Flatten[
Values[
Map[
ColorAssociation[graph,##,k]&,Subsets[VertexList[graph],{2}]
]
]
]
];

KColorsTest[graph_,{x_,y_},a_]:=Module[
{g=graph,v1=x,v2=y,len=a},

path=FindPath[
graph,x,y,{a,Infinity},All];

Highlightedpaths=Map[
HighlightGraph[graph,##,GraphHighlightStyle->"Dashed"]&,Map[PathGraph[##,VertexLabels->"Name"]&,
FindPath[
graph,x,y,{a,Infinity},All],{1}
]];

assoc=PositionIndex[
Map[
Length,
Map[
DeleteDuplicates,
Map[
PropertyValue[
{graph,##},EdgeStyle]&,
Map[
EdgeList,
Map[PathGraph[#,VertexLabels->"Name"]&,
path]
]
,{2}]
]
]
];

keys=
DeleteMissing[
Keys[
assoc]
/.b_/;b<a->Missing[]];

Association[
"Vertex Pairs"->
{x,y},
"Paths with k or more colors"->
Map[#->Highlightedpaths[[Lookup[assoc,#]]]&,keys]
]
];

KColorDataset[graph_,k_]:=
Dataset[Map[
KColorsTest[graph,##,k]&,
Subsets[
VertexList[graph],{2}]
]
];

PathLookup[dataset_,vertexpair_,kcolors_]:=
Table[
dataset[
vertexpair,"Paths"][[i]],
{i,Lookup[dataset[vertexpair,"Paths with k or more colors"]//Normal,kcolors]}
];


IsomorphismTest[graph_, a_] :=
 PositionIndex[
  Map[
   IsomorphicGraphQ[graph, #] &,
   a]
  ];



Clear[IsomorphismModule]
IsomorphismModule[graphset_] := Module[{set = graphset},
Clear[Indices,TotalGraphSet,ComparisonSet,length];
Indices=List[];
  TotalGraphSet = List[];
  ComparisonSet=set;
  length=Length[set];
  q=0;
  Print[
  TraditionalForm["Separating into equivalence classes..."]];
  Print[ProgressIndicator[Dynamic[q],{0,Length[graphset]}]];
While[Length[Flatten[TotalGraphSet]]!=Length[graphset],
Clear[Indices];
Indices=IsomorphismTest[First[ComparisonSet],ComparisonSet][True];
q=q+Length[Indices];
TotalGraphSet=Append[TotalGraphSet,Map[Part[ComparisonSet,#]&,Indices]];
ComparisonSet=Delete[ComparisonSet,Map[{#}&,Indices]];
];
Return[TotalGraphSet];
  ];




KPaths[graph_, k_] :=
 Map[
  KPathTest[graph, ##, k] &,
  Subsets[VertexList[graph], {2}]
  ];


CompleteBipartiteEdgeAdder[vertices_, list_, chords_, pathlength_] := Module[
  {n = vertices, l = list, v = chords, k = pathlength},
  graphset = Map[
    EdgeAdd[CycleGraph[n], ##] &,
    Subsets[
     Complement[
      EdgeList[
       CirculantGraph[n, l]],
      EdgeList[
       CycleGraph[n]]], {v}
     ]
    ];

  isographs = Catch[IsomorphismModule[graphset]];
  dataset = Map[KPaths[#, k] &, isographs];
  kpathgraphs = PositionIndex[
    Map[
     DeleteDuplicates[
       Flatten[
        StringCases[
         Lookup[##, "Path at least k exists"], "No"]]] &,
     dataset
     ]
    ];
  graphs = Map[isographs[[#]] &, kpathgraphs[{}]];
  Print[graphs];
  ];



ChordedCycle[vertices_, chords_, pathlength_] := Module[
  {n = vertices, v = chords, k = pathlength},
  EdgesForChordedCycle=Subsets[Complement[
      EdgeList[
       CompleteGraph[n]],
      EdgeList[
       CycleGraph[n]]],{v}];
       
       m=0;
       
       Print[TraditionalForm["Generating graphs..."]];
       
       Print[ProgressIndicator[Dynamic[m],{0,Length[EdgesForChordedCycle]}]];
       
  graphset = Map[
    (m++;EdgeAdd[CycleGraph[n], #]) &,
     EdgesForChordedCycle
     ];
    
    Print[TraditionalForm["Checking for graph isomorphism..."]];
    
  isographs = IsomorphismModule[graphset];
  
  r=0;
  
  Print[TraditionalForm["Checking for paths of length k..."]];
  
  Print[ProgressIndicator[Dynamic[r],{0,Length[isographs]}]];
  
  dataset = Map[(r++;KPaths[First[#], k]) &, isographs];
  
  kpathgraphs = PositionIndex[
    Map[
     DeleteDuplicates[
       Flatten[
        StringCases[
         Lookup[##, "Path at least k exists"], "No"]]] &,
     dataset
     ]
    ];
    
  graphs = Map[isographs[[#]] &, kpathgraphs[{}]];
  
  Return[graphs];
  ];



SetAttributes[UndirectedEdge,Orderless];

ParallelChords[list1_,list2_]:=Inner[UndirectedEdge,list1,list2,List];

(* We do not claim the below function, it was found in the Wolfram documentation and modified for this package. *)
panelLabel[lbl_]:=Panel[lbl,FrameMargins->0,Background->Lighter[White,0.7]];

CompleteBipartiteEdgeColorer[vertices_]:=
Module[
{n=vertices},
If[OddQ[n],
Print["Input must be an even number"];
Abort[];
,
Continue];
OddSet=Table[i,{i,1,n,2}];
EvenSet=Table[i,{i,2,n,2}];
Colors=RandomColor[2n-1];
(*Print[Colors];*)
CycleColors=Colors[[1;;n]];
Colors=Drop[Colors,n];
matchings=If[
EvenQ[n/2],
Map[
ParallelChords[
Reverse[EvenSet],
RotateLeft[OddSet,#]]&,
Range[n/2]],
Map[
ParallelChords[
RotateRight[Reverse[EvenSet],#],
OddSet]&,
Range[n/2]]
];

IndependentEdgeCovers=
Apply[
UndirectedEdge,
matchings,
{2}];

CycleEdgesFromIEC=
Flatten[Map[
Intersection[EdgeList[CycleGraph[n]],#]&,
IndependentEdgeCovers]];

(*Print[CycleEdgesFromIEC];*)

ColoredCycleEdges=
Table[
Style[
CycleEdgesFromIEC[[i]],
CycleColors[[i]]],
{i,1,n}];

(*Print["test"];*)

Chords=Table[
Complement[
IndependentEdgeCovers[[i]],
CycleEdgesFromIEC],
{i,1,n/2}];

(*Print["test"];*)

ColoredChords=
Flatten[
Table[
Style[
Chords[[i,j]],
Colors[[i]]
],
{i,1,n/2},
{j,1,n/2-2}]];

(*Print["test"];*)

FullGraph=Graph[
Range[n],
Union[
ColoredCycleEdges,
ColoredChords],
GraphLayout->"CircularEmbedding",
EdgeStyle->Thickness[.01]];

Return[FullGraph];
];
 End[]
 EndPackage[]
